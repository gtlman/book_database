# <center>索引</center>
## 索引原理
索引本质上是对数据库一个或多个列进行排序的数据结构，因为目的是为了提升查找速度，因而也是一种查找结构。
###查找结构的进化史
|名称|查找方式|优点|不足|
|:-:|:-:|:-:|:-:|
|线形结构（最原始）|遍历|简单，插入快|查找速度最慢|
|哈希HASH|哈希映射|查找最快->O(1)|大量额外空间，大数据不适用|
|二分结构|二分查找|查找快->logN|要求数据有序，插入较慢|
|二叉查找树|树查找|查找快->logN，插入快|容易退化为线性结构|
|AVL平衡树|树查找|解决树的退化问题|当N非常大时，logN依旧很大|
|B-Tree（多个子节点）|树查找|因为有多个子节点，树高度较低|无法得到数据库常见的范围查询|
|B+Tree|树查找|基于B-Tree实现范围查询|.|

### B+Tree
MySQL用B+Tree实现索引，B+Tree是在B-Tree的基础上的变形，只有叶子节点带有指向数据的指针，并且叶子节点通过指针现相连从而实现范围查询的功能。在形状上就像是一个B-Tree搭在一条已排序的线性结构上。

## 索引类型
### 从功能角度划分
|类型|格式|
|:-:|:-:|
|普通索引|INDEX name (column_name)|
|多列索引|INDEX name (column1_name，column2_name...)|
|唯一索引|UNIQUE (column_name)|
|主键索引|PRIMARY KEY  (column_name)|
### 从存储结构角度划分
1. 聚集索引
2. 非聚集索引

#### 聚集索引
InnoDB的主键索引就是唯一的聚集索引，B+Tree的叶子节点存储的是数据节点，因此InnoDB的数据文件就是一个聚集索引（MyISAM的聚集索引比非聚集索引只多了一个约束，与InnoDB不同），也因此通过主键查询可以直接得到所有列的值。
#### 非聚集索引
InnoDB除了主键索引，普通、多列、唯一都属于非聚集索引。非聚集索引B+Tree的叶子节点存储的是主键值，因此通过非聚集索引查询需要两次，第一次查出主键值，第二次根据主键值查出对应的行，也因此通过聚集索引（主键）的速度总是比非聚集索引的速度要快。

## 索引的使用原则
### 索引优点
- 加速查找
- 如果建了索引，查询优化器会针对索引进行SQL优化
- 索引中的唯一索引能保证数据的唯一性

### 索引缺点
- 创建索引需要耗费时间和空间
- 虽然加速查找，但是在增删改操作的时候需要同步维护索引，降低了速度
既然建索引有好有坏，那什么时候该创建呢？

### 创建索引的场景
1. 经常用作where条件的查询
2. 经常用作表连接的字段
3. 经常用作排序，分组的字段（order by，group by）
在以上场景，是不是任何类型字段都应创建索引呢？

### 索引对不同类型字段的效果
1. 索引字段存在NULL值的无法创建索引，因为NULL代表未确定，无法进行比较，也就无法排序。可以通过默认值来解决这个问题。
2. 区分度/选择性很低的字段（譬如SEX），这样的字段会导致树退化得很严重。
3. 字段数据量很大的（譬如BLOB，Text），这样的索引因为长度很大，比较很耗时间，提高不了多少。
上述第2和第3分别代表了**选择性**和**长度**两个概念，因此针对VARCHAR字符串类型字段建索引时，要兼顾选择性和长度来设置排前缀，这就是所谓的前缀索引。
索引的创建就是以上这些，但是查找有时候却会“弃用”索引，出现索引失效的现象。

### 索引失效
**模糊匹配**：以%开头的LIKE语句，因为头部条件的模糊会导致法利用索引的有序特性

**隐式类型转换**：这个是指（一般是在使用ORM的时候）因为程序在生成SQL语句时发生了隐式类型转换导致比较失败。PS：本
人暂时没遇到过就是了，不过好像是比较容易发生在python这类动态语言中

**最左匹配失败**：其实模糊匹配也算是这的一种，不过这个更常见在多列索引中，譬如你以（a,b,c）三个字段创建多列索引，那么查询可能会无法利用到该多列索引。

|查询条件|是否利用到索引|
|:-:|:-:|
|a|成功|
|a and b|成功|
|a and b and c|成功|
|b and c|失败，最左匹配失败|
|a and c|只用到a的那一部分|
|c and b and a|成功，MySQL会自动优化SQL|